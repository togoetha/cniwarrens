/* SPDX-License-Identifier: GPL-2.0 */
/*#include <linux/in6.h>
#include <linux/ipv6.h>
#include <stddef.h>
#include <linux/udp.h>
#include <stdio.h>
#include <arpa/inet.h>
#include <linux/if_ether.h>

struct in6_ipport {
	struct in6_addr n_netmask;
	struct in6_addr n_daddr;
	struct in6_addr n_saddr;
	__u32 port;
	unsigned char smac[6];
};

static __always_inline __u16 udp_csum(__u8 *packet, __u32 len, struct in6_addr src, struct in6_addr dest) {
    __u32 csum = 0;

    int i = 0;
    for (i = 0; i < 8; i++) {
        csum += htons(src.in6_u.u6_addr16[i]); //might needs bpf_htons if switching to non-network order addresses in config
        csum += htons(dest.in6_u.u6_addr16[i]);
    }
    csum += len;
    csum += 0x11;

    while (len > 1) {
        csum += (*packet) * 256 + (*(packet+1));
        packet += 2;
        len -= 2;
    }

    while (csum >> 16)
        csum = (csum & 0xFFFF) + (csum >> 16);

    return (__u16)(0xFFFF - csum);
}

void main(int argc, char *arvg[]) {
    //struct in6_addr src;
    /*2a 02 05 78
    85 20 0d 01 
    63 a9 96 cd 
    9a a1 93 5f*/
    /*src.in6_u.u6_addr32[0] = 0x2a020578;
    src.in6_u.u6_addr32[1] = 0x85200d01;
    src.in6_u.u6_addr32[2] = 0x63a996cd;
    src.in6_u.u6_addr32[3] = 0x9aa1935f;*/
    /*
    20 01 06 a8 
    1d 80 20 31 
    02 25 90 ff 
    fe 4c 76 a0*/
    /*struct in6_addr dest;
    dest.in6_u.u6_addr32[0] = 0x200106a8;
    dest.in6_u.u6_addr32[1] = 0x1d802031;
    dest.in6_u.u6_addr32[2] = 0x022590ff;
    dest.in6_u.u6_addr32[3] = 0xfe4c76a0;

    struct in6_addr result;
    const char *ip6str = "fd53:7769:726c:25de:3944:6397:4f57:1234";
    inet_pton(AF_INET6, ip6str, &result);
    result.in6_u.u6_addr32[3] = (result.in6_u.u6_addr32[3] & 0xFFFF) + (1 << 24);

    __u32 len = 0x70;

    __u8 data[] = { 0x7a,0x69,0x7a,0x69
                    ,0x00,0x70,0x00,0x00
                    ,0x60,0x00,0x64,0xf8
                    ,0x00,0x40,0x3a,0x40
                    ,0xfd,0x53,0x77,0x69
                    ,0x72,0x6c,0x25,0xde
                    ,0x39,0x44,0x63,0x97
                    ,0x4f,0x57,0x00,0x01
                    ,0xfd,0x53,0x77,0x69
                    ,0x72,0x6c,0xd6,0xbb
                    ,0xf5,0xac,0x16,0xe2
                    ,0x3d,0xbc,0x00,0x01
                    ,0x80,0x00,0xed,0xa4
                    ,0x00,0x02,0x00,0x0a
                    ,0x17,0x03,0x7e,0x63
                    ,0x00,0x00,0x00,0x00
                    ,0x30,0x2d,0x0c,0x00
                    ,0x00,0x00,0x00,0x00
                    ,0x10,0x11,0x12,0x13
                    ,0x14,0x15,0x16,0x17
                    ,0x18,0x19,0x1a,0x1b
                    ,0x1c,0x1d,0x1e,0x1f
                    ,0x20,0x21,0x22,0x23
                    ,0x24,0x25,0x26,0x27
                    ,0x28,0x29,0x2a,0x2b
                    ,0x2c,0x2d,0x2e,0x2f
                    ,0x30,0x31,0x32,0x33
                    ,0x34,0x35,0x36,0x37 };

    void* packet = (void*)data;

    int csum = udp_csum(packet, len, src, dest);
    printf("checksum %04x\n", csum);*/

    /*struct ipv6hdr iphdr;
    iphdr.saddr = src;
    iphdr.daddr = dest;
    iphdr.payload_len = 0x70;
    iphdr.nexthdr = 0x11;
    iphdr.hop_limit = 64;
    iphdr.version = 6;

    void* ipptr = (void*)&iphdr;
    __u8* ipnptr = ipptr;
    for (int i = 0; i < sizeof(struct ipv6hdr); i++) {
        printf("%02x ", ipnptr[i]);
    }*/

/*0xdc,0x39,0x6f,0xec
            ,0x50,0x35,0x44,0x03
            ,0x2c,0xdc,0x2b,0x52
            ,0x86,0xdd,0x60,0x04
            ,0x74,0x6f,0x00,0x70
            ,0x11,0x40,0x2a,0x02
            ,0x05,0x78,0x85,0x20
            ,0x0d,0x01,0x63,0xa9
            ,0x96,0xcd,0x9a,0xa1
            ,0x93,0x5f,0x20,0x01
            ,0x06,0xa8,0x1d,0x80
            ,0x20,0x31,0x02,0x25
            ,0x90,0xff,0xfe,0x4c
            ,0x7a,0x69,0x7a,0x69
            ,0x00,0x70,0x00,0x00*/
 /*   __u8 cdata[] = { 
            0x60,0x00,0x64,0xf8
            ,0x00,0x40,0x3a,0x40
            ,0xfd,0x53,0x77,0x69
            ,0x72,0x6c,0x25,0xde
            ,0x39,0x44,0x63,0x97
            ,0x4f,0x57,0x00,0x01
            ,0xfd,0x53,0x77,0x69
            ,0x72,0x6c,0xd6,0xbb
            ,0xf5,0xac,0x16,0xe2
            ,0x3d,0xbc,0x00,0x01
            ,0x80,0x00,0xed,0xa4
            ,0x00,0x02,0x00,0x0a
            ,0x17,0x03,0x7e,0x63
            ,0x00,0x00,0x00,0x00
            ,0x30,0x2d,0x0c,0x00
            ,0x00,0x00,0x00,0x00
            ,0x10,0x11,0x12,0x13
            ,0x14,0x15,0x16,0x17
            ,0x18,0x19,0x1a,0x1b
            ,0x1c,0x1d,0x1e,0x1f
            ,0x20,0x21,0x22,0x23
            ,0x24,0x25,0x26,0x27
            ,0x28,0x29,0x2a,0x2b
            ,0x2c,0x2d,0x2e,0x2f
            ,0x30,0x31,0x32,0x33
            ,0x34,0x35,0x36,0x37 };

    __u8 cdata2[] = { 0x00,0x00, 
            0x00,0x00,0x00,0x00
            ,0x00,0x00,0x00,0x00
            ,0x00,0x00,0x00,0x00
            ,0x00,0x00,0x00,0x00
            ,0x00,0x00,0x00,0x00
            ,0x00,0x00,0x00,0x00
            ,0x00,0x00,0x00,0x00
            ,0x00,0x00,0x00,0x00
            ,0x00,0x00,0x00,0x00
            ,0x00,0x00,0x00,0x00
            ,0x00,0x00,0x00,0x00
            ,0x00,0x00,0x00,0x00
            ,0x00,0x00,0x00,0x00
            ,0x00,0x00,0x00,0x00
            ,0x00,0x00,0x00,0x00
            ,0x60,0x00,0x64,0xf8
            ,0x00,0x40,0x3a,0x40
            ,0xfd,0x53,0x77,0x69
            ,0x72,0x6c,0x25,0xde
            ,0x39,0x44,0x63,0x97
            ,0x4f,0x57,0x00,0x01
            ,0xfd,0x53,0x77,0x69
            ,0x72,0x6c,0xd6,0xbb
            ,0xf5,0xac,0x16,0xe2
            ,0x3d,0xbc,0x00,0x01
            ,0x80,0x00,0xed,0xa4
            ,0x00,0x02,0x00,0x0a
            ,0x17,0x03,0x7e,0x63
            ,0x00,0x00,0x00,0x00
            ,0x30,0x2d,0x0c,0x00
            ,0x00,0x00,0x00,0x00
            ,0x10,0x11,0x12,0x13
            ,0x14,0x15,0x16,0x17
            ,0x18,0x19,0x1a,0x1b
            ,0x1c,0x1d,0x1e,0x1f
            ,0x20,0x21,0x22,0x23
            ,0x24,0x25,0x26,0x27
            ,0x28,0x29,0x2a,0x2b
            ,0x2c,0x2d,0x2e,0x2f
            ,0x30,0x31,0x32,0x33
            ,0x34,0x35,0x36,0x37 };

    void* data = (void*) cdata;
    void* mdata = (void*) cdata2;
    /*struct ethhdr* ethh = start;

    struct ipv6hdr* ipv6 = (void*)(ethh + 1);
    ipv6->saddr.in6_u.u6_addr32[3] = (ipv6->saddr.in6_u.u6_addr32[3] & 0xFFFF) + (1 << 24);*/
 /*   struct ipv6hdr *ip6h;
	ip6h = (void *)(data); //(eth + 1);

	if (ip6h->version != 6) {
		
	}

	struct in6_addr ip_dst_addr = ip6h->daddr;
	struct in6_ipport tninfo;

    struct in6_addr src;
    struct in6_addr dst;
    struct in6_addr mask;
    const char *ip6src = "2a02:0578:8520:0d01:63a9:96cd:9aa1:935f";
    const char *ip6msk = "fd53:7769:726c:d6bb:f5ac:16e2:3dbc:1";
    const char *ip6dst = "2001:06a8:1d80:2031:0225:90ff:fe4c:76a0";
    inet_pton(AF_INET6, ip6src, &src);
    inet_pton(AF_INET6, ip6dst, &dst);
    //mask = dst;
    inet_pton(AF_INET6, ip6msk, &mask);
    //mask.in6_u.u6_addr32[3] = (mask.in6_u.u6_addr32[3] & 0xFFFF) + (1 << 24);

	tninfo.port = 31337;
    tninfo.n_netmask = mask;
    tninfo.n_saddr = src;
    tninfo.n_daddr = dst;

    struct in6_addr daddrmaskd = ip_dst_addr;
    daddrmaskd.in6_u.u6_addr16[7] = 0x0100;
    //if (daddrmaskd == mask)
    {
		//bpf_printk("tunnel info"); //, &(tninfo->ip), &(tninfo->port));

		int ethlen = sizeof(struct ethhdr);
		int iplen = sizeof(struct ipv6hdr);
		int udplen = sizeof(struct udphdr);
		int newhlen = ethlen + iplen + udplen;
		
		int oldlen = ntohs(ip6h->payload_len) + iplen;

		//bpf_printk("packet start %p end %p\n", data, data_end); //, &ip_src_addr);

		/*int ret = bpf_xdp_adjust_head(ctx, -newhlen);
		if (ret != 0) {
			bpf_printk("failed to adjust for new header length\n"); 
		}*/

		//data_end = (void *)(long)ctx->data_end;
		//data     = (void *)(long)ctx->data;
		//bpf_printk("packet start %p end %p\n", data, data_end);

/*		struct ethhdr* newethh = mdata;


		newethh->h_proto = htons(ETH_P_IPV6);
		//newethh->h_source = tninfo->smac;

		struct ipv6hdr* newipv6h = (void*)(newethh + 1);


		newipv6h->daddr = tninfo.n_daddr; //TODO BYTE ORDER?
		newipv6h->saddr = tninfo.n_saddr; //TODO BYTE ORDER?
		newipv6h->version = 0x6;
		newipv6h->hop_limit = 64;
		newipv6h->nexthdr = IPPROTO_UDP;
		newipv6h->payload_len = htons(oldlen + udplen);

		struct udphdr* udph = (void*)(newipv6h + 1);


		//int* start = data;
		udph->source = htons(31337);
		udph->dest = htons(tninfo.port);
		short paylen = oldlen + udplen;
		udph->len = htons(paylen);
		udph->check = htons(udp_csum((void*)udph, paylen, tninfo.n_saddr, tninfo.n_daddr));
        printf("checksum %04x\n", ntohs(udph->check));

        for (int i = 0; i < newhlen + oldlen; i++) {
            printf("%02x ", ((__u8*)mdata)[i]);
        }
	}
}*/